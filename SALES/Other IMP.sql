 CREATE DATABASE EMPLOYEE;
USE EMPLOYEE;
CREATE TABLE DATA_SALARIES(work_year INT,
experience_level INT ,
employment_type VARCHAR(20),
job_title VARCHAR (100),
salary INT ,
salary_currency VARCHAR (50),
salary_in_usd INT,
employee_residence VARCHAR(100),
remote_ratio INT,
company_location VARCHAR(100),
company_size VARCHAR (20));
SELECT * FROM SALARIES;



/** 1.find the total number of employees in each dept**/
select JOB_TITLE , COUNT(*) FROM SALARIES GROUP BY JOB_TITLE;
SELECT JOB_TITLE,COUNT(*) FROM SALARIES GROUP BY JOB_TITLE;

/** Calculate the moving average for subset 3 days **/
SELECT * FROM SALARIES;
SELECT 

/** find the lowest salary in each department **/
WITH JOB_SALARY AS (SELECT JOB_TITLE,MIN(SALARY) AS MINIMUM_SALARY FROM SALARIES GROUP BY JOB_TITLE)
SELECT JS.* FROM  SALARIES JS
JOIN JOB_SALARY J ON JS.JOB_TITLE = J.JOB_TITLE AND JS.SALARY=J.MINIMUM_SALARY;

/** 1. THIRD HIGHEST SALARY **/
WITH SALARYRANK AS (SELECT SALARY,DENSE_RANK()OVER(ORDER BY SALARY DESC) AS RAN 
FROM SALARIES)
SELECT SALARY FROM SALARYRANK WHERE RAN = 2;

SELECT DISTINCT SALARY FROM SALARIES
ORDER BY SALARY DESC
LIMIT 1 OFFSET 2;

SELECT SALARY,DENSE_RANK()OVER(ORDER BY SALARY DESC) AS RAN 
FROM SALARIES;

/** wildcards practice **/
SELECT * FROM SALARIES;
SELECT * FROM  SALARIES WHERE JOB_TITLE NOT LIKE "%M%";

use campusx;
CREATE TABLE swiggy_orders (
    orderid INT PRIMARY KEY,
    custid INT,
    city VARCHAR(50),
    del_partner VARCHAR(50),
    order_time DATETIME,
    deliver_time DATETIME,
    predicted_time INT -- Predicted delivery time in minutes
);

show tables;
INSERT INTO swiggy_orders (orderid, custid, city, del_partner, order_time, deliver_time, predicted_time)
VALUES(1, 101, 'Mumbai', 'Partner A', '2024-12-18 10:00:00', '2024-12-18 11:30:00', 60),
(2, 102, 'Delhi', 'Partner A', '2024-12-18 09:00:00', '2024-12-18 10:00:00', 45),
(3, 103, 'Pune', 'Partner A', '2024-12-18 15:00:00', '2024-12-18 15:30:00', 30),
(4, 104, 'Mumbai', 'Partner A', '2024-12-18 14:00:00', '2024-12-18 14:50:00', 45),
(5, 105, 'Bangalore', 'Partner B', '2024-12-18 08:00:00', '2024-12-18 08:29:00', 30),
(6, 106, 'Hyderabad', 'Partner B', '2024-12-18 13:00:00', '2024-12-18 14:00:00', 70),
(7, 107, 'Kolkata', 'Partner B', '2024-12-18 10:00:00', '2024-12-18 10:40:00', 45),
(8, 108, 'Delhi', 'Partner B', '2024-12-18 18:00:00', '2024-12-18 18:30:00', 40),
(9, 109, 'Chennai', 'Partner C', '2024-12-18 07:00:00', '2024-12-18 07:40:00', 30),
(10, 110, 'Mumbai', 'Partner C', '2024-12-18 12:00:00', '2024-12-18 13:00:00', 50),
(11, 111, 'Delhi', 'Partner C', '2024-12-18 09:00:00', '2024-12-18 09:35:00', 30),
(12, 112, 'Hyderabad', 'Partner C', '2024-12-18 16:00:00', '2024-12-18 16:45:00', 30);


/** Calulate the number of delayed orders for each delivery partner**/
select * from swiggy_orders;
SELECT DEL_PARTNER,SUM(CASE WHEN TIMESTAMPDIFF(MINUTE,ORDER_TIME,DELIVER_TIME)>PREDICTED_TIME THEN 1 ELSE 0 END) AS TOTAL_DELAY_ORDERS FROM SWIGGY_ORDERS
GROUP BY DEL_PARTNER
ORDER BY TOTAL_DELAY_ORDERS DESC;

SELECT  del_partner,SUM(CASE WHEN TIMESTAMPDIFF(MINUTE,ORDER_TIME,DELIVER_TIME)>PREDICTED_TIME THEN 1 ELSE 0 END) AS DELAY_ORDERS FROM swiggy_orders
/*WHERE TIMESTAMPDIFF(MINUTE,ORDER_TIME,DELIVER_TIME)>PREDICTED_TIME*/
GROUP BY del_partner
ORDER BY DELAY_ORDERS DESC;

USE CAMPUSX;
CREATE TABLE SWIGGY_SALES(
    order_date DATE,
    customer_id INT,
    store_id INT,
    product_id INT,
    sale INT,
    order_value INT
);


INSERT INTO SWIGGY_SALES (order_date, customer_id, store_id, product_id, sale, order_value)
VALUES
('2024-12-01', 109, 1, 3, 2, 700),
('2024-12-02', 110, 2, 2, 1, 300),
('2024-12-03', 111, 1, 5, 3, 900),
('2024-12-04', 112, 3, 1, 2, 500),
('2024-12-05', 113, 3, 4, 4, 1200), 
('2024-12-05', 114, 3, 4, 2, 400),
('2024-12-05', 115, 3, 4, 1, 300),
('2024-12-01', 101, 1, 4, 2, 500),
('2024-12-01', 102, 1, 4, 1, 300),
('2024-12-02', 103, 2, 4, 3, 900),
('2024-12-02', 104, 2, 4, 1, 400),
('2024-12-03', 105, 1, 4, 2, 600),
('2024-12-03', 106, 1, 4, 3, 800),
('2024-12-04', 107, 3, 4, 1, 200),
('2024-12-04', 108, 3, 4, 2, 500);

/** ON WHICH DATE THE 3 RD HIGHEST SALE OF THE PRODUCT 1 TAKE PLACE IN TERMS OF THE VALUE**/
SELECT * FROM SWIGGY_SALES;
SELECT ORDER_DATE , SUM(ORDER_VALUE) AS DAILY_SALES FROM SWIGGY_SALES WHERE PRODUCT_ID = 4
GROUP BY ORDER_DATE ORDER BY DAILY_SALES DESC
LIMIT 2,1; /** LIMT WILL GIVE TWO VALUES BUT HERE IT OFFSET THESE FIRST TWO AND GIVE ONE VALUE AFTER OFFSET FIRST TWO VALUES I.E THIRD HIGH VALUE**/




